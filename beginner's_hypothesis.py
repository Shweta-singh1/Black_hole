# -*- coding: utf-8 -*-
"""beginner's_hypothesis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/113rShUM_hvgF0Pq-_XiNVFypJzDhYkz0

Importing libraries
"""

# Commented out IPython magic to ensure Python compatibility.
#libraries for data visualisation
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline

df=pd.read_csv(r'train.csv')

pd.DataFrame(df)

# Look at the distribution of samples for each black hole
print(df['target'].value_counts())

sns.pairplot(df, hue='target')

df.columns

df['ang_class']

df.info()

df.describe()

sns.pairplot(df,hue='b_class')

sns.jointplot(y='radio_frequency',x='target',data=df,hue='target')

sns.jointplot(y='radio_frequency',x='target',data=df,hue='target')

sns.jointplot(x='ang_class',y='target',data=df)

# the column 'angle_class' is useless

df.head(10)

sns.jointplot(x='capture_rad',y='target',data=df)

df['radio_frequency'].isna().sum()

# Factorize the 'target' column
df['target_num'] = pd.factorize(df['target'])[0]

df.head(10)

# Look at the distribution of samples for each black hole
print(df['target_num'].value_counts())

# Iterate over all columns except for 'target' and 'target_num'
for col in df.columns:
    if col not in ['target', 'target_num','ang_class']:
        
        # Calculate the group means for the column
        group_means = df.groupby('target_num')[col].mean()
        print(group_means)
        
        # Fill the null values with the corresponding group means
        df[col] = df.apply(lambda x: group_means[x['target_num']] if pd.isnull(x[col]) else x[col], axis=1)

df['radio_frequency'].isna().sum()
df['capture_rad'].isna().sum()
df['dist_from_obs_ly'].isna().sum()
df['star1_redshift'].isna().sum()
df['star2_redshift'].isna().sum()
df['b_class'].isna().sum()

df.corr()

from sklearn.preprocessing import LabelEncoder
import pickle


# Instantiate a LabelEncoder object
le = LabelEncoder()

# Fit the encoder to the target column and transform the column
y_train = le.fit_transform(df['target'])

# Check the unique values in y_train
print(set(y_train))

# Map the encoded numbers to the black hole names
class_names = le.classes_

for i, class_name in enumerate(class_names):
    print(f"{class_name} is mapped to {i}")

df.head()

X_train =df[['luminosity', 'capture_rad','radio_frequency','B_field','dist_from_obs_ly','star1_redshift','star2_redshift','ext_temp','b_class']]

from xgboost import XGBClassifier

# Instantiate an XGBClassifier object
xgb = XGBClassifier()

# Fit the model to the training data
xgb.fit(X_train, y_train)

test_df=pd.read_csv(r'test.csv')

# Select the features for testing
X_test = test_df[['luminosity', 'capture_rad','radio_frequency','B_field','dist_from_obs_ly','star1_redshift','star2_redshift','ext_temp','b_class']]

# Make predictions on the test data set
y_pred = xgb.predict(X_test)

# Convert the numerical predictions back into black hole names
y_pred_names = le.inverse_transform(y_pred)

y_pred_names

# Create the submission DataFrame
submission_df = pd.DataFrame({
    'ID': test_df.index,
    'target(Black Hole)': y_pred_names # Rename the target column
})

submission_df

# Save the submission DataFrame to a CSV file
submission_df.to_csv('submission3.csv', index=False)

